<p>You can read the Methodology below or download the presentation in pdf format 
    <a href="https://drive.google.com/file/d/15eQz5nBPGU91nwV7BMWEFnRbiweXqh91/view?usp=sharing">here</a>.<br> You also can see it in 
    Google Slides <a href="https://docs.google.com/presentation/d/1_Qgw9g_TyJrDWh6bWTYAh58TuygqWNqr0CpP_4HFBBw/edit?usp=sharing">here</a>.</p>

<h3 id="problem_definition">Problem definition</h3>
<p>Super-Resolution is the process of calculating high-resolution samples from their low-resolution counterparts. Trends in quality assessment 
    of upscaled videos and images are favoring estimation of statistical naturalness in combination with fidelity. But restoration fidelity 
    is much more important than statistical naturalness for some tasks. Some VSR methods may produce the wrong digit or an entirely
    different face. Whether a method’s results are trustworthy depends on how well it restores truthful details. Our benchmark is aimed 
    to find the best algorithms for the restoration of real details during Video Super Resolution processing.</p>

<h3 id="dataset">Dataset</h3>
<h4 id="content_types">Content types</h4>
<p>To analyze a VSR model’s ability to restore real details, we built a test 
    stand containing patterns that are difficult for video restoration (Figure 1).</p>
<div class="center">
    <div>
        <img width="50%" src="/assets/img/benchmarks/vsr/parts.jpg">
        <p><i>Figure 1. The test-stand of the benchmark.</i></p>
    </div>
</div>
<p>To calculate metrics for particular content types
    and to verify how a model works with different inputs,
    we divide each output frame into parts by detecting
    crosses:<br>
<b>Part 1. “Board”</b> includes a few small objects and photos of human faces*. Our goal is to obtain results for the model operating on textures with
small details. The striped fabric and balls of
yarn may produce a Moire pattern (Figure 2).
Restoration of human faces is important for
video surveillance.<br>
<b>Part 2. “QR”</b> comprises multiple QR codes of differing sizes; the aim is to find the size of the
smallest recognizable one in the model’s output frame. A low-resolution frame may blend
QR-code patterns, so models may have difficulty restoring them.<br>
<b>Part 3. “Text”</b> includes two kinds: handwritten and
typed. Packing all these difficult elements into
the training dataset is a challenge, so they are
each new to the model as it attempts to restore
them.<br>
<b>Part 4. “Metal paper”</b> contains foil that was vigorously crumpled. It’s an interesting example
because of the reflections, which change periodically between frames.<br>
<b>Part 5. “Color lines”</b> is a printed image with numerous
thin color stripes. This image is difficult because thin lines of similar colors end up mixing in low-resolution frames.<br>
<b>Part 6. ‘License-plate numbers”</b> consists of a set of
car license plates of varying sizes from different countries**. This content is important for
video surveillance and dashcam development<br>
<b>Part 7. “Noise”</b> includes difficult noise patterns. Models cannot restore real ground-truth noise, and
each one produces a unique pattern<br>
<b>Part 8. “Resolution test chart”</b> contains a resolution test chart with
patterns that are difficult to restore: a set of
straight and curved lines of differing thicknesses and directions<br>
*Photos were generated by <sup><a href="#references">[1]</a></sup>.<br>
**The license-plate numbers are generated randomly and printed on paper.</p>
<div class="center">
    <div>
        <video autoplay loop muted playsinline width="75%">
            <source src="/assets/img/benchmarks/vsr/muar.av1.mp4" type='video/mp4'>
            <source src="/assets/img/benchmarks/vsr/muar.vp9.webm" type='video/webm'>
            <source src="/assets/img/benchmarks/vsr/muar.x264.mp4" type='video/mp4'>
        </video>
        <p><i>Figure 2. Example of a Moire pattern on the “Board”.</i></p>
    </div>
</div>
<h4 id="content_types">Motion types</h4>
<p>The dataset includes three videos with different types of motion:
    <ul>
        <li><b>Hand tremor</b> — video shooting from the fixed point without a tripod (the photographer holds the camera in his hands). Because of the natural tremor of hands, there is a random small motion in frames
        </li>
        <div class="center">
                <img src = "/assets/img/benchmarks/vsr/motion1.png" />
                <video autoplay loop muted playsinline>
                    <source src="/assets/img/benchmarks/vsr/test1.av1.mp4" type='video/mp4'>
                    <source src="/assets/img/benchmarks/vsr/test1.vp9.webm" type='video/webm'>
                    <source src="/assets/img/benchmarks/vsr/test1.x264.mp4" type='video/mp4'>
                </video>
        </div>
        <li><b>Parallel motion</b> — the camera is moving from side to side in parallel with test-stand</li>
        <div class="center">
                <img src = "/assets/img/benchmarks/vsr/motion2.png" />
                <video autoplay loop muted playsinline>
                    <source src="/assets/img/benchmarks/vsr/test2.av1.mp4" type='video/mp4'>
                    <source src="/assets/img/benchmarks/vsr/test2.vp9.webm" type='video/webm'>
                    <source src="/assets/img/benchmarks/vsr/test2.x264.mp4" type='video/mp4'>
                </video>
        </div>
        <li><b>Rotation</b> — the camera is moving from side to side in a half-circle</li>
        <div class="center">
                <img src = "/assets/img/benchmarks/vsr/motion3.png" />
                <video autoplay loop muted playsinline>
                    <source src="/assets/img/benchmarks/vsr/test3.av1.mp4" type='video/mp4'>
                    <source src="/assets/img/benchmarks/vsr/test3.vp9.webm" type='video/webm'>
                    <source src="/assets/img/benchmarks/vsr/test3.x264.mp4" type='video/mp4'>
                </video>
        </div>
    </ul>
</p>
<h4 id="technical">Technical characteristics of the camera</h4>
<p>We captured the dataset using a Canon EOS 7D
    camera. We quickly took a series of 100 photos and
    used them as a video sequence. The shots were from
    a fixed point without a tripod, so the video contains
    a small amount of random motion. We stored the
    video as a sequence of frames in PNG format, converted from JPG. The camera’s settings were:<br>
    ISO – 4000<br>
    aperture – 400<br>
    resolution – 5184x3456
    </p>
<h4 id="dataset_preparation">Dataset preparation</h4>
<p>
    <ul>
        <li><b>Source video</b> has a resolution of 5184x3456 and was stored in the sRGB color space. Each video’s length is 100 frames.</li>
        <li><b>Ground-truth</b>. Each video was degraded by bicubic interpolation to generate a GT of resolution 1920x1280. This step is
            essential because many open-source models lack the
            code to process a large frame; processing large frames
            is also time consuming.</li>
        <li>Then <b>input video</b> was degraded from GT in two ways: bicubic interpolation (BI) and Downsamlping after Gaussian Blurring (BD).</li>
    </ul>
</p>
<h4 id="noise_input">Noise input</h4>
<p>To verify how a model works with noisy data, we prepared noise counterparts for each input video. To generate realistic noise, we use python implementation <sup><a href="#references">[2]</a></sup>
    of the noise model proposed in CBDNet by Liu et al <sup><a href="#references">[3]</a></sup>. We need to set two parameters: one for the Poisson part of the noise and another for the Gauss part of 
    the noise.<br>
To estimate the level of real noise in our camera, we set a camera on a tripod and capture a sequence of 100 frames from a fixed point. Then we average the sequence 
to estimate a clean image. Thus we gain hundred of real noise examples. Then we chose parameters for generated noise so that the distributions of generated and real 
noise are similar (see Figure 3). Our parameters choice: sigma_s = 0.001, sigma_c = 0.035.</p>
<div class="center">
    <div style="width:75%">
        <img src="/assets/img/benchmarks/vsr/noise.jpg">
        <p><i>Figure 3. The distribution of real and generated noise.</i></p>
    </div>
</div>
<p>Finally, we have 12 tests:</p>
<div class="center">
    <div style="width:90%">
        <img src="/assets/img/benchmarks/vsr/test_names.png">
    </div>
</div>
<h3 id="metrics">Metrics</h3>
<h4 id="psnr">PSNR</h4>
<p>PSNR – commonly used metric based on pixels’ similarity. We noticed that a model, trained on one degradation type and tested on another type, can generate 
    frames with a global shift relative to GT (see Figure 4). Thus we checked integer shifts from [-3,3] in both axes and choose the shift with maximal PSNR value. 
    This maximal value is considered as a metric result in our benchmark.</p>
<div class="center">
    <div style="width:75%">
        <video autoplay loop muted playsinline>
            <source src="/assets/img/benchmarks/vsr/shift.av1.mp4" type='video/mp4'>
            <source src="/assets/img/benchmarks/vsr/shift.vp9.webm" type='video/webm'>
            <source src="/assets/img/benchmarks/vsr/shift.x264.mp4" type='video/mp4'>
        </video>
        <p><i>Figure 4. On the left: The same crop from the model’s output and GT frame.<br>
            On the right: PSNR visualization for this crop.</i></p>
    </div>
</div>
<p>We chose PSNR-Y because it’s more efficient than PSNR-RGB. Meanwhile, a correlation between these metrics is high. For metric calculation, we use the 
    implementation from skimage.metrics<sup><a href="#references">[4]</a></sup>. A higher metric value indicates better quality. The metric value for GT is infinite.</p>
<h4 id="ssim">SSIM</h4>
<p>SSIM – another commonly used metric based on structure similarity. A shift of frames can influence this metric too. Thus we tried to find the optimal 
    shift similarly to PSNR calculation and noticed that optimal shifts for these metrics can differ, but not more than 1 pixel in any axis. Because SSIM 
    has large computational complexity, we decided to find optimal shift not among all shifts, but near with optimal shift for PSNR (in a distance of 1 pixel 
    in any axis). We calculate SSIM on the Y channel of the YUV color space. For metric calculation, we use the implementation from skimage.metrics<sup><a href="#references">[5]</a></sup>. A higher 
    metric value indicates better quality. The metric value for GT is 1.</p>
<h4 id="erqa">ERQAv1.0</h4>
<p>ERQAv1.0 (Edge Restoration Quality Assessment, version 1.0) estimates how well a model has restored edges of the high-resolution frame. Firstly, we find
    edges in both output and GT frames. To do it we use OpenCV implementation<sup><a href="#references">[6]</a></sup> of the Canny algorithm<sup><a href="#references">[7]</a></sup>. A threshold for the initial finding of strong edges 
    is set to 200. And a threshold for edge linking is set to 100. These coefficients allow to highlight edges of all subjects even of small sizes but skip lines, 
    which are not important (see Figure 5).</p>
<div class="center">
    <div style="width:90%">
        <img src="/assets/img/benchmarks/vsr/edge1.jpg">
        <p><i>Figure 5. An example of edges, highlighted by the chosen algorithm</i></p>
    </div>
</div>
<p>Then we compare these edges by using F1-score. To compensate a one-pixel shift of edge, which is not essential for human perception of objects, we consider 
    as true-positive pixels of output’s edges, which are not in edges of GT but are near (on the difference of one pixel) with the edge of GT(see Figure 6). 
    A higher metric value indicates better quality. The metric value for GT is 1.
</p>
<div class="center">
    <div style="width:90%">
        <img src="/assets/img/benchmarks/vsr/edge2.jpg">
        <p><i>Figure 6. Visualization of F1-score, used for edges comparison</i></p>
    </div>
</div>
<h4 id="qrcr">QRCRv1.0</h4>
<p>QRCRv1.0 (QR-Codes Restoration, version 1.0) finds the smallest size (in pixels) of QR-code, which can be detected in output frames of a model. 
    To project metric values on [0,1], we consider a relation of the smallest QRs’ sizes for GT and output frame (see Figure 7). If in the model’s result 
    we can’t detect any QR-code, the metric value is set to 0. A higher metric value indicates better quality. The metric value for GT is 1.
</p>
<div class="center">
    <div style="width:60%">
        <img src="/assets/img/benchmarks/vsr/qr.jpg">
        <p><i>Figure 7. Example of detected crosses in output and GT frame.<br>
            The metric value for the output frame is 0.65</i></p>
    </div>
</div>
<h4 id="crrm">CRRMv1.0</h4>
<p>CRRMv1.0 (Colorfullness Reduced-Reference Metric, version 1.0) – calculate colorfullness* in both frames and compare them. To calculate colorfullness we 
    use metric, proposed by Hasler et al.<sup><a href="#references">[8]</a></sup>. Comparison of colorfullness levels is performed as a relation between colorfullness in GT frame and output frame. 
    Then to project metric on [0,1] and penalize both increasing and decreasing of colorfullness, we take the absolute difference between 1 and the relation and 
    then subtract it from 1. A higher metric value indicates better quality. The metric value for GT is 1.<br>
    *Colorfulness measures how colorful an image is: if it’s bright and has a lot of different colors.
    </p>

<h3 id="metrics_acc">Metrics accumulation</h3>
<p>Because each model can work differently on different content types, we consider metric values not only on full-frame but also on parts with different content.
    To do this we detect crosses in frames and calculate coordinates of all parts from them.<br>
    Crosses in some frames are distorted and cannot be detected. Thus we choose keyframes, where we can detect all crosses and calculate metrics only on these 
    keyframes. We noticed that metrics values on these keyframes are highly correlated and choose the mean of values through keyframes as a final metric value 
    for each test case.</p>

<h3 id="subjective">Subjective comparison</h3>
<p>We cut the sequences to 30 frames and converted them
    to 8 frames per second (fps). This length allows subjects to easily consider details and decide which video
    is better. We then cropped from each video 10 snippets that cover the most difficult patterns for restora-
    tion and conducted a side-by-side pairwise subjective
    evaluation using the Subjectify.us service, which enables crowd-sourced comparisons.</p>

<p>To estimate information fidelity, <b>we asked participants</b> in the subjective comparison to avoid choosing
    the most beautiful video, but instead <b>choose the one
    that shows better detail restoration</b>. Participants are
    not experts in this field thus they do not have professional biases. Each participant was shown 25 paired
    videos and in each case had to choose the best video
    (“indistinguishable” was also an option). Each pair of
    snippets was shown to 10-15 participants until confidence interval stops changing. Three of pairs for
    each participant are for verification, so the final results exclude their answers. All other responses* from
    1400 successful participants are used to predict subjective scores using the Bradley-Terry.
    *Answers to verification questions are not included in the final result.</p>

<h3 id="fps">The computational complexity of models</h3>
<p>We tested each model using NVIDIA Titan RTX and measured runtime on the same test sequence:
    <ul>
        <li>Test case — parallel motion + BD degradation + with noise</li>
        <li>100 frames</li>
        <li>Input resolution — 480×320</li>
    </ul>
    FPS is calculated as the execution time of a full model runtime divided by the number of sequence frames.
</p>

<h3 id="references">References</h3>
<ol>
    <li><a href="https://thispersondoesnotexist.com">https://thispersondoesnotexist.com</a></li>
    <li><a href="https://github.com/yzhouas/CBDNet_ISP">https://github.com/yzhouas/CBDNet_ISP</a></li>
    <li>Shi Guo, Zifei Yan, Kai Zhang, Wangmeng Zuo and Lei Zhang, "Toward Convolutional Blind Denoising of Real Photographs," 2019 IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR), 2019, pp. 1712-1722, doi: 10.1109/CVPR.2019.00181.</li>
    <li><a href="https://scikit-image.org/docs/stable/api/skimage.metrics.html#skimage.metrics.peak_signal_noise_ratio">https://scikit-image.org/docs/stable/api/skimage.metrics.html#skimage.metrics.peak_signal_noise_ratio</a></li>
    <li><a href="https://scikit-image.org/docs/stable/api/skimage.metrics.html#skimage.metrics.structural_similarity">https://scikit-image.org/docs/stable/api/skimage.metrics.html#skimage.metrics.structural_similarity</a></li>
    <li><a href="https://docs.opencv.org/3.4/dd/d1a/group__imgproc__feature.html#ga04723e007ed888ddf11d9ba04e2232de">https://docs.opencv.org/3.4/dd/d1a/group__imgproc__feature.html#ga04723e007ed888ddf11d9ba04e2232de</a></li>
    <li><a href="https://en.wikipedia.org/wiki/Canny_edge_detector">https://en.wikipedia.org/wiki/Canny_edge_detector</a></li>
    <li>David Hasler and Sabine Suesstrunk, "Measuring Colourfulness in Natural Images," Proceedings of SPIE - The International Society for Optical Engineering, 2003, volume 5007, pp. 87-95, doi: 10.1117/12.477378.</li>
</ol>
